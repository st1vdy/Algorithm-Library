\documentclass{article}
\usepackage{fancyhdr}  % 页眉页脚
\usepackage{ctex}
\usepackage[margin=1in]{geometry}
\usepackage[Glenn]{fncychap}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}	
\usepackage{amsmath}

\geometry{a4paper,left=2cm,right=2cm,top=2.5cm,bottom=2cm}

% 定义页眉页脚
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{Algorithm Library by st1vdy}
\lfoot{}
\cfoot{\thepage}
\rfoot{}

\title{Algorithm Library}
\author{st1vdy}

\definecolor{dkgreen}{rgb}{0,0,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
    language=c++,                               % 设置默认语言
    breaklines,                                 % 自动将长的代码行换行排版
    extendedchars=false,                        % 解决代码跨页时，章节标题，页眉等汉字不显示的问题
    backgroundcolor=\color{white},              % 背景颜色
    keywordstyle=\color{blue}\bfseries,         % 关键字颜色
    identifierstyle=\color[rgb]{0,0,0},         % 普通标识符颜色
    commentstyle=\color[rgb]{0,0.6,0},          % 注释颜色
    stringstyle=\color[rgb]{0.58,0,0.82},       % 字符串颜色
    showstringspaces=false,                     % 不显示字符串内的空格
    numbers=left,                               % 显示行号
    captionpos=t,                               % title在上方(在bottom即为b)
    frame=single,                               % 设置代码框形式
    rulecolor=\color[rgb]{0,0,0},               % 设置代码框颜色
}

\begin{document}
\begin{titlepage}
\maketitle
\thispagestyle{empty}
\pagebreak
\pagestyle{plain}
\tableofcontents
\end{titlepage}
%\twocolumn  % 是否需要分栏显示
\newpage % 另起一页
\section{多项式} %一级标题
\subsection{FFT - tourist}
\lstinputlisting{polynomial/fft_tourist.cpp}
\subsection{形式幂级数}
\lstinputlisting{polynomial/fps.cpp}

\section{数论}
\subsection{简单的防爆模板}
\subsubsection{类型1}
\lstinputlisting{number_theory/mod.cpp}
\subsubsection{类型2}
\lstinputlisting{number_theory/mod2.cpp}
\subsection{筛法}
\subsubsection{线性素数筛}
\lstinputlisting{number_theory/sieve.cpp}
\subsubsection{线性欧拉函数筛}
\lstinputlisting{number_theory/phi_sieve.cpp}
\subsubsection{线性约数个数函数筛}
\lstinputlisting{number_theory/div_sieve.cpp}
\subsubsection{线性素因子个数函数筛}
\lstinputlisting{number_theory/pdiv_sieve.cpp}
\subsubsection{线性约数和函数筛}
\lstinputlisting{number_theory/sigma_sieve.cpp}
\subsubsection{线性莫比乌斯函数筛}
\lstinputlisting{number_theory/mobius_sieve.cpp}
\subsection{Pollard-Rho}
\lstinputlisting{number_theory/pollard_rho.cpp}
\subsection{扩展欧几里得}
\subsubsection{线性同余方程最小非负整数解}
exgcd求 $ax+by=c$ 的最小非负整数解详解：
\begin{enumerate}
    \item 求出 $a,b$ 的最大公约数 $g=\gcd(a,b)$ ，根据裴蜀定理检查是否满足 $c\% g=0$ ，不满足则无解；
    \item 调整系数 $a,b,c$ 为 $a'=\frac{a}{g},b'=\frac{b}{g},c'=\frac{c}{g}$ ，这是因为 $ax+by=c$ 和 $a'x+b'y=c'$ 是完全等价的；
    \item 实际上exgcd求解的方程是 $a'x+b'y=1$ ，求解前需要注意让系数 $a',b'\geq 0$ （举个例子，如果系数 $b'$ 原本 $<0$ ，我们可以翻转 $b'$ 的符号然后令解 $(x,y)$ 为 $(x,-y)$ ，但是求解的时候要把 $y$ 翻回来）；
    \item 我们通过exgcd求出一组解 $(x_0,y_0)$ ，这组解满足 $a'x_0+b'y_0=1$ ，为了使解合法我们需要令 $x_0=c'x_0,y_0=c'y_0$ ，于是有 $a'(c'x_0)+b'(c'y_0)=c''$ ；
    \item 考虑到 $a'x_0+b'y_0=1$ 等价于同余方程 $a'x_0\equiv 1\pmod{b'}$ ，因此为了求出最小非负整数解，我们最后还需要对 $b'$ 取模；
    \item 最后注意特判 $c'=0$ 的情况，如果要求解 $y$ 且系数 $b$ 发生了翻转，将其翻转回来。
\end{enumerate}
\lstinputlisting{number_theory/exgcd.cpp}
\subsubsection{一定范围内线性方程整数解数}
exgcd通解：假设我们通过上方的exgcd流程获得了一组解 $(x_0,y_0)$ （没有乘 $c$ ），那么 $a'x+b'y=1$ 的通解就是 $(x_0+b't,y_0-a't)$ ，因此 $a'x+b'y=c'$ 的通解是 $(c'(x_0+b't),c'(y_0-a't))$ 。
\lstinputlisting{number_theory/exgcd2.cpp}
\subsection{类欧几里得}
\subsubsection{Naive}
$$
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
$$

原理：

$$
\begin{aligned}
f(a,b,c,n)&=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor\\
&=\sum_{i=0}^n\left\lfloor
\frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+a\bmod c\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+b\bmod c\right)}{c}\right\rfloor\\
&=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+
\sum_{i=0}^n\left\lfloor\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c}
\right\rfloor\\
&=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor
+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n)
\end{aligned}
$$
\lstinputlisting{number_theory/euclid_like_naive.cpp}
\subsubsection{General}
$$
\begin{aligned}
f(a,b,c,n,k1,k2)=\sum_{i=0}^{n}i^{k_1}{\lfloor \frac{ai+b}{c} \rfloor}^{k_2}
\end{aligned}
$$
\lstinputlisting{number_theory/euclid_like.cpp}

\subsection{Wilson定理}
假设 $p$ 是素数，则有：

$$
(p-1)! \equiv -1 \pmod{p}
$$

否则除了 $p=4$ 时，$(p-1)!\equiv 0 \pmod{p}$ .

\subsection{欧拉定理}

$$
a^b\equiv
\begin{cases}
a^{b\bmod\varphi(p)},\,&\gcd(a,\,p)=1\\
a^b,&\gcd(a,\,p)\ne1,\,b<\varphi(p)\\
a^{b\bmod\varphi(p)+\varphi(p)},&\gcd(a,\,p)\ne1,\,b\ge\varphi(p)
\end{cases}
\pmod p
$$

\subsection{欧拉函数}
\subsubsection{暴力单点查询}
\lstinputlisting{number_theory/euler_func_bf.cpp}
\subsubsection{预处理单点查询}
\lstinputlisting{number_theory/euler_func_pre.cpp}
\subsection{中国剩余定理}
\subsubsection{CRT}
\lstinputlisting{number_theory/crt.cpp}
\subsubsection{EXCRT}
\lstinputlisting{number_theory/excrt.cpp}
\subsection{BSGS}
\lstinputlisting{number_theory/bsgs.cpp}
\subsection{二次剩余}
\lstinputlisting{number_theory/tonelli_shanks.cpp}
\subsection{迪利克雷卷积}

$$
\begin{aligned}
g(1)S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{i=2}^ng(i)S(\lfloor\frac{n}{i}\rfloor)
\end{aligned}
$$

\subsection{杜教筛}

$$
\begin{aligned}
(f*g)(n)=\underset{d|n}{\sum} f(d)g(\frac{n}{d})=\underset{xy=n}{\sum} f(x)g(y)
\end{aligned}
$$

\subsection{Berlekamp Massey}
\lstinputlisting{number_theory/bm.cpp}

\section{线性代数}
\subsection{矩阵}
\subsection{高斯-约旦消元法}
\lstinputlisting{linear_algebra/gauss.cpp}
\subsection{高斯消元法-bitset}
\lstinputlisting{linear_algebra/gauss_bitset.cpp}
\subsection{线性基}
\lstinputlisting{linear_algebra/linear_basis.cpp}
\subsection{矩阵树定理}
\lstinputlisting{linear_algebra/matrix_tree.cpp}
\subsection{LGV引理}
一般用于有向无环图不相交路径计数（常见于网格图）。

$$
M = \begin{bmatrix}e(A_1,B_1)&e(A_1,B_2)&\cdots&e(A_1,B_n)\\ 
e(A_2,B_1)&e(A_2,B_2)&\cdots&e(A_2,B_n)\\ 
\vdots&\vdots&\ddots&\vdots\\ 
e(A_n,B_1)&e(A_n,B_2)&\cdots&e(A_n,B_n)\end{bmatrix}\\ 
\det(M)=\sum\limits_{S:A\rightarrow B}(-1)^{N(\sigma(S))}\prod\limits_{i=1}^n \omega(S_i)
$$

\section{组合数学}
\subsection{组合数预处理}
\lstinputlisting{combinatorics/binom.cpp}
\subsection{卢卡斯定理}

对于质数 $p$，有：

$$
\begin{aligned}
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p
\end{aligned}
$$

\lstinputlisting{combinatorics/lucas.cpp}

\subsection{小球盒子模型}

设有 $n$ 个球，$k$ 个盒子：

\begin{enumerate}
    \item 球之间互不相同，盒子之间互不相同，可以空盒

   根据乘法原理，答案就是 $k^n$ 。

    \item 球之间互不相同，盒子之间互不相同，每个盒子至多装一个球

   相当于每个球找一个没有被选过的盒子放进去，答案是 $k^{\underline{n}}$ ，即 $k(k-1)\cdots(k-n+1)$ 。

    \item 球之间互不相同，盒子之间互不相同，每个盒子至少装一个球

   可以先把盒子视为相同：$n$ 个球放进 $k$ 个相同盒子、不能空盒，这就是第二类斯特林数 $S^k_n$ 的定义。最后由于盒子不同，再乘上一个排列数，因此答案就是 $k!S^k_n$ 。

    \item 球之间互不相同，盒子全部相同，可以空盒

   枚举非空盒子数量，相当于第二类斯特林数一行求和：$\sum_{i=1}^{k}S^i_n$ 。

    \item 球之间互不相同，盒子全部相同，每个盒子至多装一个球

   因为盒子相同，不论怎么放都是一样的，答案是 $[n\leq k]$（这是一个布尔运算式，若 $n\leq k$ 成立则取 $1$ ，否则 $0$）。

    \item 球之间互不相同，盒子全部相同，每个盒子至少装一个球

   就是第二类斯特林数 $S_n^k$ 。

    \item 球全部相同，盒子之间互不相同，可以空盒

   隔板法经典应用，$n+k-1$ 个球选 $k-1$ 个板，因此答案是 $\binom{n+k-1}{k-1}$ 。

    \item 球全部相同，盒子之间互不相同，每个盒子至多装一个球

   盒子不同，相当于要选出 $n$ 个盒子装球，因此答案是 $\binom{n}{k}$ 。

    \item 球全部相同，盒子之间互不相同，每个盒子至少装一个球

   隔板法经典应用，$n-1$ 个空隙选 $k-1$ 个插板（可以看作是情况7时每个盒子里都预先加入一个球），因此答案是 $\binom{n-1}{k-1}$ 。

    \item 球全部相同，盒子全部相同，可以空盒

    定义划分数 $p_{n,k}$ 表示将自然数 $n$ 拆成 $k$ 份的方案数，那么本例的结论就是 $p_{n,k}$ 。

    这个问题有一个经典递推式：$p(n,k) = p(n,k-1) + p(n-k,k)$ 。意义是将 $j$ 个自然数 $+1$ 或者加入一个 $0$ 。下面给出一个代码实现：

    \lstinputlisting{combinatorics/p_bf.cpp}

    \item 球全部相同，盒子全部相同，每个盒子至多装一个球

    和情况5一致，就是 $[n\leq k]$ 。

    \item 球全部相同，盒子全部相同，每个盒子至少装一个球

    显然也是一个划分数：$p_{n-k,k}$ 。
\end{enumerate}

\subsection{斯特林数}
\subsubsection{第一类斯特林数}

第一类斯特林数 $\begin{bmatrix}n\\k\end{bmatrix}$ 表示将 $n$ 个不同元素划分入 $k$ 个非空圆排列的方案数。

$$
\begin{bmatrix}
n \\ k
\end{bmatrix}
=
\begin{bmatrix}
n-1 \\ k-1
\end{bmatrix}
+
(n-1)\begin{bmatrix}
n-1 \\ k
\end{bmatrix}
$$

边界是 $\begin{bmatrix}0\\0\end{bmatrix}=1$ 。

第一类斯特林数三角形，从 s(1, 1) 开始：

$$
\begin{matrix}
1 \\
1 & 1 \\
2 & 3 & 1 \\
6 & 11 & 6 & 1 \\
24 & 50 & 35 & 10 & 1 \\
120 & 274 & 225 & 85 & 15 & 1 \\
720 & 1764 & 1624 & 735 & 175 & 21 & 1 \\
5040 & 13068 & 13132 & 6769 & 1960 & 322 & 28 & 1 \\
40320 & 109584 & 118124 & 67284 & 22449 & 4536 & 546 & 36 & 1 \\
362880 & 1026576 & 1172700 & 723680 & 269325 & 63273 & 9450 & 870 & 45 & 1 \\
\end{matrix}
$$


\subsubsection{第二类斯特林数}

第二类斯特林数 $\begin{Bmatrix} n\\k \end{Bmatrix}$ 表示将 $n$ 个不同元素划分为 $k$ 个非空子集的方案数。

$$
\begin{aligned}
\begin{Bmatrix} n\\k \end{Bmatrix}
=
\begin{Bmatrix} n-1\\k-1 \end{Bmatrix}
+
k\begin{Bmatrix} n-1\\k \end{Bmatrix}
\end{aligned}
$$

边界是 $\begin{Bmatrix}0\\0\end{Bmatrix}=1$ 。

基于容斥原理的递推方法：

$$
\begin{aligned}
\begin{Bmatrix} n\\k \end{Bmatrix} =
\frac{1}{k!}\sum^k_{i=0}(-1)^i\binom{k}{i}(k-i)^n
\end{aligned}
$$

第二类斯特林数三角形，从 S(1, 1) 开始：

$$
\begin{matrix}
1 \\
1 & 1 \\
1 & 3 & 1 \\
1 & 7 & 6 & 1 \\
1 & 15 & 25 & 10 & 1 \\
1 & 31 & 90 & 65 & 15 & 1 \\
1 & 63 & 301 & 350 & 140 & 21 & 1 \\
1 & 127 & 966 & 1701 & 1050 & 266 & 28 & 1 \\
1 & 255 & 3025 & 7770 & 6951 & 2646 & 462 & 36 & 1 \\
1 & 511 & 9330 & 34105 & 42525 & 22827 & 5880 & 750 & 45 & 1 \\
\end{matrix}
$$

\section{博弈论}
\subsection{SG定理}
一个状态的SG函数值是它所有后继状态的MEX，当MEX为 $0$ 时该状态后手必胜，反之先手必胜。当某个游戏由多个独立的子游戏组成时，所有子游戏的SG函数异或和为 $0$ 时后手必胜，否则先手必胜。

在Nim博弈中的简单应用：显然第 $i$ 堆石子的SG函数值就是它的石子数量 $a_i$ ，每一堆石子都是一个独立的子游戏，因此 $a_0\oplus a_1\oplus\cdots a_{n-1}=0$ 时后手必胜，否则先手必胜。

\subsection{Bash博弈}
一共 $N$ 个石子，先后手轮流取石子，每次最多取 $M$ 个石子，先取完者获胜。

先手必胜：$N \pmod{M+1} \neq 0$ ；必败：$N \pmod{(M+1)} = 0$。

\subsection{Nim-K博弈}
有 $N$ 堆石子，先后手轮流取石子，每次最多可以选择 $K$ 堆石子，被选中的每堆石子都可以取任意个，先取完者获胜。

把 $N$ 堆石子的石子数量都用二进制表示，对于二进制意义下的每一位，如果 $1$ 的数量在模 $K+1$ 意义下\textbf{全部}为 $0$ ，则先手必败。

\subsection{Anti-Nim博弈}
规则和Nim博弈一致，但是获胜条件改为：不能取石子的一方获胜。

满足以下任意条件，则先手必胜：

\begin{enumerate}
    \item 所有堆的石子数量 $\leq 1$ 并且异或和 $=0$ 。
    \item 至少存在一堆石子个数 $\geq 2$ 并且异或和 $\neq 0$ 。
\end{enumerate}

\subsection{Anti-SG博弈}
SG博弈中最先不能行动的一方获胜。
满足以下任意条件，则先手必胜：

\begin{enumerate}
    \item SG为 $0$ 并且每一个游戏的SG都不超过 $1$ 。
    \item SG不为 $0$ 并且至少有一个游戏的SG大于 $1$ 。
\end{enumerate}

\subsection{阶梯博弈}
有 $N$ 个阶梯（下标从 $0$ 开始），每个阶梯上有一定数量的石子，先后手轮流行动，每次可以从一个阶梯上拿走任意个石子放到下一层阶梯上，最先不能操作者失败。

SG函数为奇数阶梯上的石子的异或和，如果移动偶数层的石子到奇数层，对手一定可以继续移动这些石子到偶数层使得SG不变。

\subsection{Wythoff博弈}
有两堆石子，石子数量分别为 $A,B$ ，每次可以从一堆或者两堆里拿走\textbf{相同数量}的石子，最先不能取石子的人输。

必败态为：$A_k=\lfloor \frac{k(1+\sqrt{5})}{2}\rfloor, B_k=a_k + k$，假设 $A_k<B_k$ 。

\subsection{树上删边博弈}
给定一棵 $N$ 个点的有根树，两人轮流操作，每次删除树上的一条边，然后删除所有不与根节点联通的部分，最先不能进行删除操作的人失败。

所有叶子节点的SG函数值为 $0$ ，非叶子节点的SG值为其所有子节点（SG值+1）的异或和。

\subsection{无向图删边博弈}
和树上删边博弈的规则一样，不过给出的是一个无向图。

可以将图中的任意一个偶环缩成一个新点，任意一个奇环缩成一个新点加一个新边；所有连到原先环上的边全部改为与新点相连。

\subsection{二分图博弈}
给出一张二分图和起点 $S$ ，先后手轮流操作，每次只能从当前点（最开始是点 $S$）移动到一个\textbf{相邻}的点，且每个点只能被\textbf{遍历一次}，无法继续移动的人输。

先手必胜：二分图的最大匹配\textbf{一定}包含起点 $S$ ；先手必败：二分图的最大匹配\textbf{不一定}包含起点 $S$ 。

\section{图论}
\subsection{并查集}
\lstinputlisting{graph/dsu.cpp}
\subsection{最短路}
\lstinputlisting{graph/dijkstra.cpp}
\subsection{最小树形图}
\lstinputlisting{graph/zhuliu.cpp}
\subsection{最近公共祖先}
\lstinputlisting{graph/lca.cpp}
\subsection{欧拉回路}
\lstinputlisting{graph/euler_circuit.cpp}
\subsection{强连通分量}
\lstinputlisting{graph/scc.cpp}
\subsection{2-sat}
\lstinputlisting{graph/twosat.cpp}
\subsection{最大流}
\lstinputlisting{graph/maxflow_acl.cpp}
\subsection{最小费用最大流}
\lstinputlisting{graph/mincostmaxflow_acl.cpp}
\subsection{全局最小割}
\lstinputlisting{graph/stoer_wagner.cpp}
\subsection{二分图最大权匹配}
\lstinputlisting{graph/km.cpp}
\subsection{一般图最大匹配}
\lstinputlisting{graph/blossom.cpp}
\subsection{最大团}
\lstinputlisting{graph/max_clique.cpp}

\section{数据结构}
\subsection{树状数组}
\lstinputlisting{data_structures/fenwick_basic.cpp}
\subsection{线段树}
\section{字符串}
\subsection{KMP}
\lstinputlisting{string/kmp.cpp}
\subsection{Z-Function}
\lstinputlisting{string/z_function.cpp}
\subsection{Manacher}
\lstinputlisting{string/manacher.cpp}
\subsection{Trie}
\lstinputlisting{string/trie.cpp}
\subsection{01-Trie}
\lstinputlisting{string/xortrie.cpp}

\section{计算几何}
\lstinputlisting{geometry/geometry.cpp}

\section{数学公式及定理}
\subsection{求导法则}
\subsection{麦克劳林级数}
\subsection{微积分}
\subsection{球缺}
\subsection{马尔可夫链}

\section{杂项}
\subsection{快速IO}
\lstinputlisting{others/fastio.cpp}
\subsection{蔡勒公式}
\lstinputlisting{others/zeller.cpp}
\subsection{枚举子集}
\subsubsection{暴力遍历}
\lstinputlisting{others/subset.cpp}
\subsubsection{遍历大小为k的子集}
\lstinputlisting{others/k_subset.cpp}
\subsection{高维前缀和/SoSDP}
\lstinputlisting{others/sos.cpp}
\subsection{压位BFS}
给定一个 $n$ 个点的有向图，当所有边权均为 $1$ 时，$O(\frac{n^3}{w})$ 求任意两点之间的最短路。
\lstinputlisting{others/bfs_bitset.cpp}
\subsection{随机数生成}
\lstinputlisting{others/random.cpp}
\subsection{简单对拍}
\lstinputlisting{others/compare.cpp}


\end{document}